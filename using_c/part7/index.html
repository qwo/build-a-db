<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Part 7 - Introduction to the B-Tree - Build a database in X</title><meta name=description content="Learn By Building"><meta name=generator content="Hugo 0.58.3"><link href=https://build-a-db.stanzheng.com/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://build-a-db.stanzheng.com/using_c/part7/><link rel=stylesheet href=https://build-a-db.stanzheng.com/css/theme.min.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://build-a-db.stanzheng.com/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://build-a-db.stanzheng.com/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1>Build a database in X</h1><span class=version>Version 1.0.0</span><p class=description>Learn By Building</p></header><div class=global-menu><nav><ul><li><a href=/>Home</a></li><li><a href=https://github.com/stanzheng/build-a-db>Github</a></li><li><a href=https://twitter.com/stanzheng>Twitter</a></li></ul></nav></div><div class=content-container><main><h1>Part 7 - Introduction to the B-Tree</h1><p>The B-Tree is the data structure SQLite uses to represent both tables and indexes, so it&rsquo;s a pretty central idea. This article will just introduce the data structure, so it won&rsquo;t have any code.</p><p>Why is a tree a good data structure for a database?</p><ul><li>Searching for a particular value is fast (logarithmic time)</li><li>Inserting / deleting a value you&rsquo;ve already found is fast (constant-ish time to rebalance)</li><li>Traversing a range of values is fast (unlike a hash map)</li></ul><p>A B-Tree is different from a binary tree (the &ldquo;B&rdquo; probably stands for the inventor&rsquo;s name, but could also stand for &ldquo;balanced&rdquo;). Here&rsquo;s an example B-Tree:</p><p><img src=/assets/images/B-tree.png description="example B-Tree (https://en.wikipedia.org/wiki/File:B-tree.svg)"></p><p>Unlike a binary tree, each node in a B-Tree can have more than 2 children. Each node can have up to m children, where m is called the tree&rsquo;s &ldquo;order&rdquo;. To keep the tree mostly balanced, we also say nodes have to have at least m/2 children (rounded up).</p><p>Exceptions:
- Leaf nodes have 0 children
- The root node can have fewer than m children but must have at least 2
- If the root node is a leaf node (the only node), it still has 0 children</p><p>The picture from above is a B-Tree, which SQLite uses to store indexes. To store tables, SQLites uses a variation called a B+ tree.</p><table><thead><tr><th></th><th>B-tree</th><th>B+ tree</th></tr></thead><tbody><tr><td>Pronounced</td><td>&ldquo;Bee Tree&rdquo;</td><td>&ldquo;Bee Plus Tree&rdquo;</td></tr><tr><td>Used to store</td><td>Indexes</td><td>Tables</td></tr><tr><td>Internal nodes store keys</td><td>Yes</td><td>Yes</td></tr><tr><td>Internal nodes store values</td><td>Yes</td><td>No</td></tr><tr><td>Number of children per node</td><td>Less</td><td>More</td></tr><tr><td>Internal nodes vs. leaf nodes</td><td>Same structure</td><td>Different structure</td></tr></tbody></table><p>Until we get to implementing indexes, I&rsquo;m going to talk solely about B+ trees, but I&rsquo;ll just refer to it as a B-tree or a btree.</p><p>Nodes with children are called &ldquo;internal&rdquo; nodes. Internal nodes and leaf nodes are structured differently:</p><table><thead><tr><th>For an order-m tree&hellip;</th><th>Internal Node</th><th>Leaf Node</th></tr></thead><tbody><tr><td>Stores</td><td>keys and pointers to children</td><td>keys and values</td></tr><tr><td>Number of keys</td><td>up to m-1</td><td>as many as will fit</td></tr><tr><td>Number of pointers</td><td>number of keys + 1</td><td>none</td></tr><tr><td>Number of values</td><td>none</td><td>number of keys</td></tr><tr><td>Key purpose</td><td>used for routing</td><td>paired with value</td></tr><tr><td>Stores values?</td><td>No</td><td>Yes</td></tr></tbody></table><p>Let&rsquo;s work through an example to see how a B-tree grows as you insert elements into it. To keep things simple, the tree will be order 3. That means:</p><ul><li>up to 3 children per internal node</li><li>up to 2 keys per internal node</li><li>at least 2 children per internal node</li><li>at least 1 key per internal node</li></ul><p>An empty B-tree has a single node: the root node. The root node starts as a leaf node with zero key/value pairs:</p><p><img src=/assets/images/btree1.png description="empty btree"></p><p>If we insert a couple key/value pairs, they are stored in the leaf node in sorted order.</p><p><img src=/assets/images/btree2.png description="one-node btree"></p><p>Let&rsquo;s say that the capacity of a leaf node is two key/value pairs. When we insert another, we have to split the leaf node and put half the pairs in each node. Both nodes become children of a new internal node which will now be the root node.</p><p><img src=/assets/images/btree3.png description="two-level btree"></p><p>The internal node has 1 key and 2 pointers to child nodes. If we want to look up a key that is less than or equal to 5, we look in the left child. If we want to look up a key greater than 5, we look in the right child.</p><p>Now let&rsquo;s insert the key &ldquo;2&rdquo;. First we look up which leaf node it would be in if it was present, and we arrive at the left leaf node. The node is full, so we split the leaf node and create a new entry in the parent node.</p><p><img src=/assets/images/btree4.png description="four-node btree"></p><p>Let&rsquo;s keep adding keys. 18 and 21. We get to the point where we have to split again, but there&rsquo;s no room in the parent node for another key/pointer pair.</p><p><img src=/assets/images/btree5.png description="no room in internal node"></p><p>The solution is to split the root node into two internal nodes, then create new root node to be their parent.</p><p><img src=/assets/images/btree6.png description="three-level btree"></p><p>The depth of the tree only increases when we split the root node. Every leaf node has the same depth and close to the same number of key/value pairs, so the tree remains balanced and quick to search.</p><p>I&rsquo;m going to hold off on discussion of deleting keys from the tree until after we&rsquo;ve implemented insertion.</p><p>When we implement this data structure, each node will correspond to one page. The root node will exist in page 0. Child pointers will simply be the page number that contains the child node.</p><p>Next time, we start implementing the btree!</p><div class=edit-meta><br><a href=https://github.com/stanzheng/build-a-db/edit/master/content/using_c/part7.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/using_c/part6/ title="Part 6 - The Cursor Abstraction"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Part 6 - The Cursor Abstraction</a>
<a class="nav nav-next" href=/using_c/part8/ title="Part 8 - B-Tree Leaf Node Format">Next - Part 8 - B-Tree Leaf Node Format <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://build-a-db.stanzheng.com/>Home</a></li><li class=parent><a href=/using_c/>How Does a Database Work? In [C]</a><ul class=sub-menu><li><a href=/using_c/part1/>Part 1 - Introduction and Setting up the REPL</a></li><li><a href=/using_c/part2/>Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine</a></li><li><a href=/using_c/part3/>Part 3 - An In-Memory, Append-Only, Single-Table Database</a></li><li><a href=/using_c/part4/>Part 4 - Our First Tests (and Bugs)</a></li><li><a href=/using_c/part5/>Part 5 - Persistence to Disk</a></li><li><a href=/using_c/part6/>Part 6 - The Cursor Abstraction</a></li><li class=active><a href=/using_c/part7/>Part 7 - Introduction to the B-Tree</a></li><li><a href=/using_c/part8/>Part 8 - B-Tree Leaf Node Format</a></li><li><a href=/using_c/part9/>Part 9 - Binary Search and Duplicate Keys</a></li><li><a href=/using_c/part10/>Part 10 - Splitting a Leaf Node</a></li><li><a href=/using_c/part11/>Part 11 - Recursively Searching the B-Tree</a></li><li><a href=/using_c/part12/>Part 12 - Scanning a Multi-Level B-Tree</a></li><li><a href=/using_c/part13/>Part 13 - Updating Parent Node After a Split</a></li></ul></li><li><a href=/using_python/>How Does a Database Work? In [Python]</a><ul class=sub-menu><li><a href=/using_python/part1/>Part 1 - Introduction and Setting up the REPL</a></li><li><a href=/using_python/part2/>Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine</a></li><li><a href=/using_python/part3/>Part 3 - An In-Memory, Append-Only, Single-Table Database</a></li><li><a href=/using_python/code/part4/>Part 4 - Our First Tests (and Bugs)</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>