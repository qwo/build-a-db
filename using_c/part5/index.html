<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Part 5 - Persistence to Disk - Build a database in X</title><meta name=description content="Learn By Building"><meta name=generator content="Hugo 0.58.3"><link href=stanzheng.com/build-a-dbindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=stanzheng.com/build-a-db/using_c/part5/><link rel=stylesheet href=stanzheng.com/build-a-db/css/theme.min.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=stanzheng.com/build-a-db/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=stanzheng.com/build-a-db/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1>Build a database in X</h1><span class=version>Version 1.0.0</span>
<a href=https://github.com/stanzheng/build_a_database class=github><i class="fab fa-github"></i></a><p class=description>Learn By Building</p></header><div class=global-menu><nav><ul><li><a href=stanzheng.com/build-a-db/>Home</a></li><li><a href=https://twitter.com/thingsym>Twitter</a></li><li><a href=stanzheng.com/build-a-db/about/>About Hugo</a></li></ul></nav></div><div class=content-container><main><h1>Part 5 - Persistence to Disk</h1><blockquote><p>&ldquo;Nothing in the world can take the place of persistence.&rdquo; &ndash; <a href=https://en.wikiquote.org/wiki/Calvin_Coolidge>Calvin Coolidge</a></p></blockquote><p>Our database lets you insert records and read them back out, but only as long as you keep the program running. If you kill the program and start it back up, all your records are gone. Here&rsquo;s a spec for the behavior we want:</p><div class=highlight><pre class=chroma><code class=language-ruby data-lang=ruby><span class=n>it</span> <span class=s1>&#39;keeps data after closing connection&#39;</span> <span class=k>do</span>
  <span class=n>result1</span> <span class=o>=</span> <span class=n>run_script</span><span class=p>(</span><span class=o>[</span>
    <span class=s2>&#34;insert 1 user1 person1@example.com&#34;</span><span class=p>,</span>
    <span class=s2>&#34;.exit&#34;</span><span class=p>,</span>
  <span class=o>]</span><span class=p>)</span>
  <span class=n>expect</span><span class=p>(</span><span class=n>result1</span><span class=p>)</span><span class=o>.</span><span class=n>to</span> <span class=n>match_array</span><span class=p>(</span><span class=o>[</span>
    <span class=s2>&#34;db &gt; Executed.&#34;</span><span class=p>,</span>
    <span class=s2>&#34;db &gt; &#34;</span><span class=p>,</span>
  <span class=o>]</span><span class=p>)</span>
  <span class=n>result2</span> <span class=o>=</span> <span class=n>run_script</span><span class=p>(</span><span class=o>[</span>
    <span class=s2>&#34;select&#34;</span><span class=p>,</span>
    <span class=s2>&#34;.exit&#34;</span><span class=p>,</span>
  <span class=o>]</span><span class=p>)</span>
  <span class=n>expect</span><span class=p>(</span><span class=n>result2</span><span class=p>)</span><span class=o>.</span><span class=n>to</span> <span class=n>match_array</span><span class=p>(</span><span class=o>[</span>
    <span class=s2>&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class=p>,</span>
    <span class=s2>&#34;Executed.&#34;</span><span class=p>,</span>
    <span class=s2>&#34;db &gt; &#34;</span><span class=p>,</span>
  <span class=o>]</span><span class=p>)</span>
<span class=k>end</span></code></pre></div><p>Like sqlite, we&rsquo;re going to persist records by saving the entire database to a file.</p><p>We already set ourselves up to do that by serializing rows into page-sized memory blocks. To add persistence, we can simply write those blocks of memory to a file, and read them back into memory the next time the program starts up.</p><p>To make this easier, we&rsquo;re going to make an abstraction called the pager. We ask the pager for page number <code>x</code>, and the pager gives us back a block of memory. It first looks in its cache. On a cache miss, it copies data from disk into memory (by reading the database file).</p><p>{% include image.html url=&ldquo;assets/images/arch-part5.gif&rdquo; description=&ldquo;How our program matches up with SQLite architecture&rdquo; %}</p><p>The Pager accesses the page cache and the file. The Table object makes requests for pages through the pager:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+typedef struct {
</span><span class=gi>+  int file_descriptor;
</span><span class=gi>+  uint32_t file_length;
</span><span class=gi>+  void* pages[TABLE_MAX_PAGES];
</span><span class=gi>+} Pager;
</span><span class=gi>+
</span><span class=gi></span> typedef struct {
<span class=gd>-  void* pages[TABLE_MAX_PAGES];
</span><span class=gd></span><span class=gi>+  Pager* pager;
</span><span class=gi></span>   uint32_t num_rows;
 } Table;
</code></pre></div><p>I&rsquo;m renaming <code>new_table()</code> to <code>db_open()</code> because it now has the effect of opening a connection to the database. By opening a connection, I mean:</p><ul><li>opening the database file</li><li>initializing a pager data structure</li><li><p>initializing a table data structure</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gd>-Table* new_table() {
</span><span class=gd></span><span class=gi>+Table* db_open(const char* filename) {
</span><span class=gi>+  Pager* pager = pager_open(filename);
</span><span class=gi>+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
</span><span class=gi>+
</span><span class=gi></span>Table* table = malloc(sizeof(Table));
<span class=gd>-  table-&gt;num_rows = 0;
</span><span class=gd></span><span class=gi>+  table-&gt;pager = pager;
</span><span class=gi>+  table-&gt;num_rows = num_rows;
</span><span class=gi></span>
return table;
}
</code></pre></div></li></ul><p><code>db_open()</code> in turn calls <code>pager_open()</code>, which opens the database file and keeps track of its size. It also initializes the page cache to all <code>NULL</code>s.</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+Pager* pager_open(const char* filename) {
</span><span class=gi>+  int fd = open(filename,
</span><span class=gi>+                O_RDWR |      // Read/Write mode
</span><span class=gi>+                    O_CREAT,  // Create file if it does not exist
</span><span class=gi>+                S_IWUSR |     // User write permission
</span><span class=gi>+                    S_IRUSR   // User read permission
</span><span class=gi>+                );
</span><span class=gi>+
</span><span class=gi>+  if (fd == -1) {
</span><span class=gi>+    printf(&#34;Unable to open file\n&#34;);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  off_t file_length = lseek(fd, 0, SEEK_END);
</span><span class=gi>+
</span><span class=gi>+  Pager* pager = malloc(sizeof(Pager));
</span><span class=gi>+  pager-&gt;file_descriptor = fd;
</span><span class=gi>+  pager-&gt;file_length = file_length;
</span><span class=gi>+
</span><span class=gi>+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
</span><span class=gi>+    pager-&gt;pages[i] = NULL;
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  return pager;
</span><span class=gi>+}
</span></code></pre></div><p>Following our new abstraction, we move the logic for fetching a page into its own method:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff> void* row_slot(Table* table, uint32_t row_num) {
   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class=gd>-  void* page = table-&gt;pages[page_num];
</span><span class=gd>-  if (page == NULL) {
</span><span class=gd>-    // Allocate memory only when we try to access page
</span><span class=gd>-    page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
</span><span class=gd>-  }
</span><span class=gd></span><span class=gi>+  void* page = get_page(table-&gt;pager, page_num);
</span><span class=gi></span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }
</code></pre></div><p>The <code>get_page()</code> method has the logic for handling a cache miss. We assume pages are saved one after the other in the database file: Page 0 at offset 0, page 1 at offset 4096, page 2 at offset 8192, etc. If the requested page lies outside the bounds of the file, we know it should be blank, so we just allocate some memory and return it. The page will be added to the file when we flush the cache to disk later.</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+void* get_page(Pager* pager, uint32_t page_num) {
</span><span class=gi>+  if (page_num &gt; TABLE_MAX_PAGES) {
</span><span class=gi>+    printf(&#34;Tried to fetch page number out of bounds. %d &gt; %d\n&#34;, page_num,
</span><span class=gi>+           TABLE_MAX_PAGES);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  if (pager-&gt;pages[page_num] == NULL) {
</span><span class=gi>+    // Cache miss. Allocate memory and load from file.
</span><span class=gi>+    void* page = malloc(PAGE_SIZE);
</span><span class=gi>+    uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
</span><span class=gi>+
</span><span class=gi>+    // We might save a partial page at the end of the file
</span><span class=gi>+    if (pager-&gt;file_length % PAGE_SIZE) {
</span><span class=gi>+      num_pages += 1;
</span><span class=gi>+    }
</span><span class=gi>+
</span><span class=gi>+    if (page_num &lt;= num_pages) {
</span><span class=gi>+      lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
</span><span class=gi>+      ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
</span><span class=gi>+      if (bytes_read == -1) {
</span><span class=gi>+        printf(&#34;Error reading file: %d\n&#34;, errno);
</span><span class=gi>+        exit(EXIT_FAILURE);
</span><span class=gi>+      }
</span><span class=gi>+    }
</span><span class=gi>+
</span><span class=gi>+    pager-&gt;pages[page_num] = page;
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  return pager-&gt;pages[page_num];
</span><span class=gi>+}
</span></code></pre></div><p>For now, we&rsquo;ll wait to flush the cache to disk until the user closes the connection to the database. When the user exits, we&rsquo;ll call a new method called <code>db_close()</code>, which</p><ul><li>flushes the page cache to disk</li><li>closes the database file</li><li><p>frees the memory for the Pager and Table data structures</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+void db_close(Table* table) {
</span><span class=gi>+  Pager* pager = table-&gt;pager;
</span><span class=gi>+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
</span><span class=gi>+
</span><span class=gi>+  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
</span><span class=gi>+    if (pager-&gt;pages[i] == NULL) {
</span><span class=gi>+      continue;
</span><span class=gi>+    }
</span><span class=gi>+    pager_flush(pager, i, PAGE_SIZE);
</span><span class=gi>+    free(pager-&gt;pages[i]);
</span><span class=gi>+    pager-&gt;pages[i] = NULL;
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  // There may be a partial page to write to the end of the file
</span><span class=gi>+  // This should not be needed after we switch to a B-tree
</span><span class=gi>+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
</span><span class=gi>+  if (num_additional_rows &gt; 0) {
</span><span class=gi>+    uint32_t page_num = num_full_pages;
</span><span class=gi>+    if (pager-&gt;pages[page_num] != NULL) {
</span><span class=gi>+      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
</span><span class=gi>+      free(pager-&gt;pages[page_num]);
</span><span class=gi>+      pager-&gt;pages[page_num] = NULL;
</span><span class=gi>+    }
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  int result = close(pager-&gt;file_descriptor);
</span><span class=gi>+  if (result == -1) {
</span><span class=gi>+    printf(&#34;Error closing db file.\n&#34;);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
</span><span class=gi>+    void* page = pager-&gt;pages[i];
</span><span class=gi>+    if (page) {
</span><span class=gi>+      free(page);
</span><span class=gi>+      pager-&gt;pages[i] = NULL;
</span><span class=gi>+    }
</span><span class=gi>+  }
</span><span class=gi>+  free(pager);
</span><span class=gi>+  free(table);
</span><span class=gi>+}
</span><span class=gi>+
</span><span class=gi></span><span class=gd>-MetaCommandResult do_meta_command(InputBuffer* input_buffer) {
</span><span class=gd></span><span class=gi>+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {
</span><span class=gi></span>if (strcmp(input_buffer-&gt;buffer, &#34;.exit&#34;) == 0) {
<span class=gi>+    db_close(table);
</span><span class=gi></span> exit(EXIT_SUCCESS);
} else {
 return META_COMMAND_UNRECOGNIZED_COMMAND;
</code></pre></div></li></ul><p>In our current design, the length of the file encodes how many rows are in the database, so we need to write a partial page at the end of the file. That&rsquo;s why <code>pager_flush()</code> takes both a page number and a size. It&rsquo;s not the greatest design, but it will go away pretty quickly when we start implementing the B-tree.</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
</span><span class=gi>+  if (pager-&gt;pages[page_num] == NULL) {
</span><span class=gi>+    printf(&#34;Tried to flush null page\n&#34;);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
</span><span class=gi>+
</span><span class=gi>+  if (offset == -1) {
</span><span class=gi>+    printf(&#34;Error seeking: %d\n&#34;, errno);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  ssize_t bytes_written =
</span><span class=gi>+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
</span><span class=gi>+
</span><span class=gi>+  if (bytes_written == -1) {
</span><span class=gi>+    printf(&#34;Error writing: %d\n&#34;, errno);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+}
</span></code></pre></div><p>Lastly, we need to accept the filename as a command-line argument. Don&rsquo;t forget to also add the extra argument to <code>do_meta_command</code>:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff> int main(int argc, char* argv[]) {
<span class=gd>-  Table* table = new_table();
</span><span class=gd></span><span class=gi>+  if (argc &lt; 2) {
</span><span class=gi>+    printf(&#34;Must supply a database filename.\n&#34;);
</span><span class=gi>+    exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  char* filename = argv[1];
</span><span class=gi>+  Table* table = db_open(filename);
</span><span class=gi>+
</span><span class=gi></span>   InputBuffer* input_buffer = new_input_buffer();
   while (true) {
     print_prompt();
     read_input(input_buffer);

     if (input_buffer-&gt;buffer[0] == &#39;.&#39;) {
<span class=gd>-      switch (do_meta_command(input_buffer)) {
</span><span class=gd></span><span class=gi>+      switch (do_meta_command(input_buffer, table)) {
</span></code></pre></div><p>With these changes, we&rsquo;re able to close then reopen the database, and our records are still there!</p><pre><code>~ ./db mydb.db
db &gt; insert 1 cstack foo@bar.com
Executed.
db &gt; insert 2 voltorb volty@example.com
Executed.
db &gt; .exit
~
~ ./db mydb.db
db &gt; select
(1, cstack, foo@bar.com)
(2, voltorb, volty@example.com)
Executed.
db &gt; .exit
~
</code></pre><p>For extra fun, let&rsquo;s take a look at <code>mydb.db</code> to see how our data is being stored. I&rsquo;ll use vim as a hex editor to look at the memory layout of the file:</p><pre><code>vim mydb.db
:%!xxd
</code></pre><p>{% include image.html url=&ldquo;assets/images/file-format.png&rdquo; description=&ldquo;Current File Format&rdquo; %}</p><p>The first four bytes are the id of the first row (4 bytes because we store a <code>uint32_t</code>). It&rsquo;s stored in little-endian byte order, so the least significant byte comes first (01), followed by the higher-order bytes (00 00 00). We used <code>memcpy()</code> to copy bytes from our <code>Row</code> struct into the page cache, so that means the struct was laid out in memory in little-endian byte order. That&rsquo;s an attribute of the machine I compiled the program for. If we wanted to write a database file on my machine, then read it on a big-endian machine, we&rsquo;d have to change our <code>serialize_row()</code> and <code>deserialize_row()</code> methods to always store and read bytes in the same order.</p><p>The next 33 bytes store the username as a null-terminated string. Apparently &ldquo;cstack&rdquo; in ASCII hexadecimal is <code>63 73 74 61 63 6b</code>, followed by a null character (<code>00</code>). The rest of the 33 bytes are unused.</p><p>The next 256 bytes store the email in the same way. Here we can see some random junk after the terminating null character. This is most likely due to uninitialized memory in our <code>Row</code> struct. We copy the entire 256-byte email buffer into the file, including any bytes after the end of the string. Whatever was in memory when we allocated that struct is still there. But since we use a terminating null character, it has no effect on behavior.</p><p><strong>NOTE</strong>: If we wanted to ensure that all bytes are initialized, it would
suffice to use <code>strncpy</code> instead of <code>memcpy</code> while copying the <code>username</code>
and <code>email</code> fields of rows in <code>serialize_row</code>, like so:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff> void serialize_row(Row* source, void* destination) {
     memcpy(destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);
<span class=gd>-    memcpy(destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);
</span><span class=gd>-    memcpy(destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);
</span><span class=gd></span><span class=gi>+    strncpy(destination + USERNAME_OFFSET, source-&gt;username, USERNAME_SIZE);
</span><span class=gi>+    strncpy(destination + EMAIL_OFFSET, source-&gt;email, EMAIL_SIZE);
</span><span class=gi></span> }
</code></pre></div><h2 id=conclusion>Conclusion</h2><p>Alright! We&rsquo;ve got persistence. It&rsquo;s not the greatest. For example if you kill the program without typing <code>.exit</code>, you lose your changes. Additionally, we&rsquo;re writing all pages back to disk, even pages that haven&rsquo;t changed since we read them from disk. These are issues we can address later.</p><p>Next time we&rsquo;ll introduce cursors, which should make it easier to implement the B-tree.</p><p>Until then!</p><h2 id=complete-diff>Complete Diff</h2><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff><span class=gi>+#include &lt;errno.h&gt;
</span><span class=gi>+#include &lt;fcntl.h&gt;
</span><span class=gi></span> #include &lt;stdbool.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdint.h&gt;
<span class=gi>+#include &lt;unistd.h&gt;
</span><span class=gi></span>
 struct InputBuffer_t {
   char* buffer;
<span class=gu>@@ -62,9 +65,16 @@ const uint32_t PAGE_SIZE = 4096;
</span><span class=gu></span> const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
 const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

<span class=gi>+typedef struct {
</span><span class=gi>+  int file_descriptor;
</span><span class=gi>+  uint32_t file_length;
</span><span class=gi>+  void* pages[TABLE_MAX_PAGES];
</span><span class=gi>+} Pager;
</span><span class=gi>+
</span><span class=gi></span> typedef struct {
   uint32_t num_rows;
<span class=gd>-  void* pages[TABLE_MAX_PAGES];
</span><span class=gd></span><span class=gi>+  Pager* pager;
</span><span class=gi></span> } Table;

<span class=gu>@@ -84,32 +94,81 @@ void deserialize_row(void *source, Row* destination) {
</span><span class=gu></span>   memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
 }

<span class=gi>+void* get_page(Pager* pager, uint32_t page_num) {
</span><span class=gi>+  if (page_num &gt; TABLE_MAX_PAGES) {
</span><span class=gi>+     printf(&#34;Tried to fetch page number out of bounds. %d &gt; %d\n&#34;, page_num,
</span><span class=gi>+     	TABLE_MAX_PAGES);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  if (pager-&gt;pages[page_num] == NULL) {
</span><span class=gi>+     // Cache miss. Allocate memory and load from file.
</span><span class=gi>+     void* page = malloc(PAGE_SIZE);
</span><span class=gi>+     uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
</span><span class=gi>+
</span><span class=gi>+     // We might save a partial page at the end of the file
</span><span class=gi>+     if (pager-&gt;file_length % PAGE_SIZE) {
</span><span class=gi>+         num_pages += 1;
</span><span class=gi>+     }
</span><span class=gi>+
</span><span class=gi>+     if (page_num &lt;= num_pages) {
</span><span class=gi>+         lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
</span><span class=gi>+         ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
</span><span class=gi>+         if (bytes_read == -1) {
</span><span class=gi>+     	printf(&#34;Error reading file: %d\n&#34;, errno);
</span><span class=gi>+     	exit(EXIT_FAILURE);
</span><span class=gi>+         }
</span><span class=gi>+     }
</span><span class=gi>+
</span><span class=gi>+     pager-&gt;pages[page_num] = page;
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  return pager-&gt;pages[page_num];
</span><span class=gi>+}
</span><span class=gi>+
</span><span class=gi></span> void* row_slot(Table* table, uint32_t row_num) {
   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class=gd>-  void *page = table-&gt;pages[page_num];
</span><span class=gd>-  if (page == NULL) {
</span><span class=gd>-     // Allocate memory only when we try to access page
</span><span class=gd>-     page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
</span><span class=gd>-  }
</span><span class=gd></span><span class=gi>+  void *page = get_page(table-&gt;pager, page_num);
</span><span class=gi></span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }

<span class=gd>-Table* new_table() {
</span><span class=gd>-  Table* table = malloc(sizeof(Table));
</span><span class=gd>-  table-&gt;num_rows = 0;
</span><span class=gd></span><span class=gi>+Pager* pager_open(const char* filename) {
</span><span class=gi>+  int fd = open(filename,
</span><span class=gi>+     	  O_RDWR | 	// Read/Write mode
</span><span class=gi>+     	      O_CREAT,	// Create file if it does not exist
</span><span class=gi>+     	  S_IWUSR |	// User write permission
</span><span class=gi>+     	      S_IRUSR	// User read permission
</span><span class=gi>+     	  );
</span><span class=gi>+
</span><span class=gi>+  if (fd == -1) {
</span><span class=gi>+     printf(&#34;Unable to open file\n&#34;);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  off_t file_length = lseek(fd, 0, SEEK_END);
</span><span class=gi>+
</span><span class=gi>+  Pager* pager = malloc(sizeof(Pager));
</span><span class=gi>+  pager-&gt;file_descriptor = fd;
</span><span class=gi>+  pager-&gt;file_length = file_length;
</span><span class=gi>+
</span><span class=gi></span>   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
<span class=gd>-     table-&gt;pages[i] = NULL;
</span><span class=gd></span><span class=gi>+     pager-&gt;pages[i] = NULL;
</span><span class=gi></span>   }
<span class=gd>-  return table;
</span><span class=gd></span><span class=gi>+
</span><span class=gi>+  return pager;
</span><span class=gi></span> }

<span class=gd>-void free_table(Table* table) {
</span><span class=gd>-  for (int i = 0; table-&gt;pages[i]; i++) {
</span><span class=gd>-     free(table-&gt;pages[i]);
</span><span class=gd>-  }
</span><span class=gd>-  free(table);
</span><span class=gd></span><span class=gi>+Table* db_open(const char* filename) {
</span><span class=gi>+  Pager* pager = pager_open(filename);
</span><span class=gi>+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
</span><span class=gi>+
</span><span class=gi>+  Table* table = malloc(sizeof(Table));
</span><span class=gi>+  table-&gt;pager = pager;
</span><span class=gi>+  table-&gt;num_rows = num_rows;
</span><span class=gi>+
</span><span class=gi>+  return table;
</span><span class=gi></span> }

 InputBuffer* new_input_buffer() {
<span class=gu>@@ -142,10 +201,76 @@ void close_input_buffer(InputBuffer* input_buffer) {
</span><span class=gu></span>   free(input_buffer);
 }

<span class=gi>+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
</span><span class=gi>+  if (pager-&gt;pages[page_num] == NULL) {
</span><span class=gi>+     printf(&#34;Tried to flush null page\n&#34;);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE,
</span><span class=gi>+     		 SEEK_SET);
</span><span class=gi>+
</span><span class=gi>+  if (offset == -1) {
</span><span class=gi>+     printf(&#34;Error seeking: %d\n&#34;, errno);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  ssize_t bytes_written = write(
</span><span class=gi>+     pager-&gt;file_descriptor, pager-&gt;pages[page_num], size
</span><span class=gi>+     );
</span><span class=gi>+
</span><span class=gi>+  if (bytes_written == -1) {
</span><span class=gi>+     printf(&#34;Error writing: %d\n&#34;, errno);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+}
</span><span class=gi>+
</span><span class=gi>+void db_close(Table* table) {
</span><span class=gi>+  Pager* pager = table-&gt;pager;
</span><span class=gi>+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
</span><span class=gi>+
</span><span class=gi>+  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
</span><span class=gi>+     if (pager-&gt;pages[i] == NULL) {
</span><span class=gi>+         continue;
</span><span class=gi>+     }
</span><span class=gi>+     pager_flush(pager, i, PAGE_SIZE);
</span><span class=gi>+     free(pager-&gt;pages[i]);
</span><span class=gi>+     pager-&gt;pages[i] = NULL;
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  // There may be a partial page to write to the end of the file
</span><span class=gi>+  // This should not be needed after we switch to a B-tree
</span><span class=gi>+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
</span><span class=gi>+  if (num_additional_rows &gt; 0) {
</span><span class=gi>+     uint32_t page_num = num_full_pages;
</span><span class=gi>+     if (pager-&gt;pages[page_num] != NULL) {
</span><span class=gi>+         pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
</span><span class=gi>+         free(pager-&gt;pages[page_num]);
</span><span class=gi>+         pager-&gt;pages[page_num] = NULL;
</span><span class=gi>+     }
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  int result = close(pager-&gt;file_descriptor);
</span><span class=gi>+  if (result == -1) {
</span><span class=gi>+     printf(&#34;Error closing db file.\n&#34;);
</span><span class=gi>+     exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
</span><span class=gi>+     void* page = pager-&gt;pages[i];
</span><span class=gi>+     if (page) {
</span><span class=gi>+         free(page);
</span><span class=gi>+         pager-&gt;pages[i] = NULL;
</span><span class=gi>+     }
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  free(pager);
</span><span class=gi>+  free(table);
</span><span class=gi>+}
</span><span class=gi>+
</span><span class=gi></span> MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {
   if (strcmp(input_buffer-&gt;buffer, &#34;.exit&#34;) == 0) {
     close_input_buffer(input_buffer);
<span class=gd>-    free_table(table);
</span><span class=gd></span><span class=gi>+    db_close(table);
</span><span class=gi></span>     exit(EXIT_SUCCESS);
   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
<span class=gu>@@ -182,6 +308,7 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {
</span><span class=gu></span>     return PREPARE_SUCCESS;

 }
<span class=gi>+
</span><span class=gi></span> PrepareResult prepare_statement(InputBuffer* input_buffer,
                                 Statement* statement) {
   if (strncmp(input_buffer-&gt;buffer, &#34;insert&#34;, 6) == 0) {
<span class=gu>@@ -227,7 +354,14 @@ ExecuteResult execute_statement(Statement* statement, Table *table) {
</span><span class=gu></span> }

 int main(int argc, char* argv[]) {
<span class=gd>-  Table* table = new_table();
</span><span class=gd></span><span class=gi>+  if (argc &lt; 2) {
</span><span class=gi>+      printf(&#34;Must supply a database filename.\n&#34;);
</span><span class=gi>+      exit(EXIT_FAILURE);
</span><span class=gi>+  }
</span><span class=gi>+
</span><span class=gi>+  char* filename = argv[1];
</span><span class=gi>+  Table* table = db_open(filename);
</span><span class=gi>+
</span><span class=gi></span>   InputBuffer* input_buffer = new_input_buffer();
   while (true) {
     print_prompt();
</code></pre></div><p>And the diff to our tests:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff> describe &#39;database&#39; do
<span class=gi>+  before do
</span><span class=gi>+    `rm -rf test.db`
</span><span class=gi>+  end
</span><span class=gi>+
</span><span class=gi></span>   def run_script(commands)
     raw_output = nil
<span class=gd>-    IO.popen(&#34;./db&#34;, &#34;r+&#34;) do |pipe|
</span><span class=gd></span><span class=gi>+    IO.popen(&#34;./db test.db&#34;, &#34;r+&#34;) do |pipe|
</span><span class=gi></span>       commands.each do |command|
         pipe.puts command
       end
<span class=gu>@@ -28,6 +32,27 @@ describe &#39;database&#39; do
</span><span class=gu></span>     ])
   end

<span class=gi>+  it &#39;keeps data after closing connection&#39; do
</span><span class=gi>+    result1 = run_script([
</span><span class=gi>+      &#34;insert 1 user1 person1@example.com&#34;,
</span><span class=gi>+      &#34;.exit&#34;,
</span><span class=gi>+    ])
</span><span class=gi>+    expect(result1).to match_array([
</span><span class=gi>+      &#34;db &gt; Executed.&#34;,
</span><span class=gi>+      &#34;db &gt; &#34;,
</span><span class=gi>+    ])
</span><span class=gi>+
</span><span class=gi>+    result2 = run_script([
</span><span class=gi>+      &#34;select&#34;,
</span><span class=gi>+      &#34;.exit&#34;,
</span><span class=gi>+    ])
</span><span class=gi>+    expect(result2).to match_array([
</span><span class=gi>+      &#34;db &gt; (1, user1, person1@example.com)&#34;,
</span><span class=gi>+      &#34;Executed.&#34;,
</span><span class=gi>+      &#34;db &gt; &#34;,
</span><span class=gi>+    ])
</span><span class=gi>+  end
</span><span class=gi>+
</span><span class=gi></span>   it &#39;prints error message when table is full&#39; do
     script = (1..1401).map do |i|
       &#34;insert #{i} user#{i} person#{i}@example.com&#34;
</code></pre></div><div class=edit-meta><br><a href=https://github.com/thingsym/hugo-theme-techdoc/edit/master/content/using_c/part5.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=stanzheng.com/build-a-db/using_c/part4/ title="Part 4 - Our First Tests (and Bugs)"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Part 4 - Our First Tests (and Bugs)</a>
<a class="nav nav-next" href=stanzheng.com/build-a-db/using_c/part6/ title="Part 6 - The Cursor Abstraction">Next - Part 6 - The Cursor Abstraction <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=stanzheng.com/build-a-db>Home</a></li><li class=parent><a href=stanzheng.com/build-a-db/using_c/>How Does a Database Work? In [C]</a><ul class=sub-menu><li><a href=stanzheng.com/build-a-db/using_c/part1/>Part 1 - Introduction and Setting up the REPL</a></li><li><a href=stanzheng.com/build-a-db/using_c/part2/>Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine</a></li><li><a href=stanzheng.com/build-a-db/using_c/part3/>Part 3 - An In-Memory, Append-Only, Single-Table Database</a></li><li><a href=stanzheng.com/build-a-db/using_c/part4/>Part 4 - Our First Tests (and Bugs)</a></li><li class=active><a href=stanzheng.com/build-a-db/using_c/part5/>Part 5 - Persistence to Disk</a></li><li><a href=stanzheng.com/build-a-db/using_c/part6/>Part 6 - The Cursor Abstraction</a></li><li><a href=stanzheng.com/build-a-db/using_c/part7/>Part 7 - Introduction to the B-Tree</a></li><li><a href=stanzheng.com/build-a-db/using_c/part8/>Part 8 - B-Tree Leaf Node Format</a></li><li><a href=stanzheng.com/build-a-db/using_c/part9/>Part 9 - Binary Search and Duplicate Keys</a></li><li><a href=stanzheng.com/build-a-db/using_c/part10/>Part 10 - Splitting a Leaf Node</a></li><li><a href=stanzheng.com/build-a-db/using_c/part11/>Part 11 - Recursively Searching the B-Tree</a></li><li><a href=stanzheng.com/build-a-db/using_c/part12/>Part 12 - Scanning a Multi-Level B-Tree</a></li><li><a href=stanzheng.com/build-a-db/using_c/part13/>Part 13 - Updating Parent Node After a Split</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>