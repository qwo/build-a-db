<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Part 1 - Introduction and Setting up the REPL - Build a database in X</title><meta name=description content="Learn By Building"><meta name=generator content="Hugo 0.58.3"><link href=http://build-a-db.stanzheng.com/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=http://build-a-db.stanzheng.com/using_c/part1/><link rel=stylesheet href=http://build-a-db.stanzheng.com/css/theme.min.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=http://build-a-db.stanzheng.com/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=http://build-a-db.stanzheng.com/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1>Build a database in X</h1><span class=version>Version 1.0.0</span><p class=description>Learn By Building</p></header><div class=global-menu><nav><ul><li><a href=/>Home</a></li><li><a href=https://github.com/stanzheng/build-a-db>Github</a></li><li><a href=https://twitter.com/stanzheng>Twitter</a></li></ul></nav></div><div class=content-container><main><h1>Part 1 - Introduction and Setting up the REPL</h1><p>As a web developer, I use relational databases every day at my job, but they&rsquo;re a black box to me. Some questions I have:
- What format is data saved in? (in memory and on disk)
- When does it move from memory to disk?
- Why can there only be one primary key per table?
- How does rolling back a transaction work?
- How are indexes formatted?
- When and how does a full table scan happen?
- What format is a prepared statement saved in?</p><p>In other words, how does a database <strong>work</strong>?</p><p>To figure things out, I&rsquo;m writing a database from scratch. It&rsquo;s modeled off sqlite because it is designed to be small with fewer features than MySQL or PostgreSQL, so I have a better hope of understanding it. The entire database is stored in a single file!</p><h1 id=sqlite>Sqlite</h1><p>There&rsquo;s lots of <a href=https://www.sqlite.org/arch.html>documentation of sqlite internals</a> on their website, plus I&rsquo;ve got a copy of <a href="https://play.google.com/store/books/details?id=9Z6IQQnX1JEC">SQLite Database System: Design and Implementation</a>.</p><p><img src=/assets/images/arch1.gif description="sqlite architecture (https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki)"></p><p>A query goes through a chain of components in order to retrieve or modify data. The <strong>front-end</strong> consists of the:
- tokenizer
- parser
- code generator</p><p>The input to the front-end is a SQL query. the output is sqlite virtual machine bytecode (essentially a compiled program that can operate on the database).</p><p>The <em>back-end</em> consists of the:
- virtual machine
- B-tree
- pager
- os interface</p><p>The <strong>virtual machine</strong> takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.</p><p>Each <strong>B-tree</strong> consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.</p><p>The <strong>pager</strong> receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.</p><p>The <strong>os interface</strong> is the layer that differs depending on which operating system sqlite was compiled for. In this tutorial, I&rsquo;m not going to support multiple platforms.</p><p><a href=https://en.wiktionary.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step>A journey of a thousand miles begins with a single step</a>, so let&rsquo;s start with something a little more straightforward: the REPL.</p><h2 id=making-a-simple-repl>Making a Simple REPL</h2><p>Sqlite starts a read-execute-print loop when you start it from the command line:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>~ sqlite3
SQLite version <span class=m>3</span>.16.0 <span class=m>2016</span>-11-04 <span class=m>19</span>:09:39
Enter <span class=s2>&#34;.help&#34;</span> <span class=k>for</span> usage hints.
Connected to a transient in-memory database.
Use <span class=s2>&#34;.open FILENAME&#34;</span> to reopen on a persistent database.
sqlite&gt; create table users <span class=o>(</span>id int, username varchar<span class=o>(</span><span class=m>255</span><span class=o>)</span>, email varchar<span class=o>(</span><span class=m>255</span><span class=o>))</span><span class=p>;</span>
sqlite&gt; .tables
users
sqlite&gt; .exit
~</code></pre></div><p>To do that, our main function will have an infinite loop that prints the prompt, gets a line of input, then processes that line of input:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
  <span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span> <span class=o>=</span> <span class=n>new_input_buffer</span><span class=p>();</span>
  <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>print_prompt</span><span class=p>();</span>
    <span class=n>read_input</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>,</span> <span class=s>&#34;.exit&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>close_input_buffer</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>
      <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Unrecognized command &#39;%s&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></div><p>We&rsquo;ll define <code>InputBuffer</code> as a small wrapper around the state we need to store to interact with <a href=http://man7.org/linux/man-pages/man3/getline.3.html>getline()</a>. (More on that in a minute)</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
  <span class=kt>char</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>
  <span class=n>size_t</span> <span class=n>buffer_length</span><span class=p>;</span>
  <span class=n>ssize_t</span> <span class=n>input_length</span><span class=p>;</span>
<span class=p>}</span> <span class=n>InputBuffer</span><span class=p>;</span>

<span class=n>InputBuffer</span><span class=o>*</span> <span class=nf>new_input_buffer</span><span class=p>()</span> <span class=p>{</span>
  <span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=n>InputBuffer</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>InputBuffer</span><span class=p>));</span>
  <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer_length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>input_length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=k>return</span> <span class=n>input_buffer</span><span class=p>;</span>
<span class=p>}</span></code></pre></div><p>Next, <code>print_prompt()</code> prints a prompt to the user. We do this before reading each line of input.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>print_prompt</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;db &gt; &#34;</span><span class=p>);</span> <span class=p>}</span></code></pre></div><p>To read a line of input, use <a href=http://man7.org/linux/man-pages/man3/getline.3.html>getline()</a>:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>ssize_t</span> <span class=nf>getline</span><span class=p>(</span><span class=kt>char</span> <span class=o>**</span><span class=n>lineptr</span><span class=p>,</span> <span class=n>size_t</span> <span class=o>*</span><span class=n>n</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>);</span></code></pre></div><p><code>lineptr</code> : a pointer to the variable we use to point to the buffer containing the read line. If it set to <code>NULL</code> it is mallocatted by <code>getline</code> and should thus be freed by the user, even if the command fails.</p><p><code>n</code> : a pointer to the variable we use to save the size of allocated buffer.</p><p><code>stream</code> : the input stream to read from. We&rsquo;ll be reading from standard input.</p><p><code>return value</code> : the number of bytes read, which may be less than the size of the buffer.</p><p>We tell <code>getline</code> to store the read line in <code>input_buffer-&gt;buffer</code> and the size of the allocated buffer in <code>input_buffer-&gt;buffer_length</code>. We store the return value in <code>input_buffer-&gt;input_length</code>.</p><p><code>buffer</code> starts as null, so <code>getline</code> allocates enough memory to hold the line of input and makes <code>buffer</code> point to it.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>read_input</span><span class=p>(</span><span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>ssize_t</span> <span class=n>bytes_read</span> <span class=o>=</span>
      <span class=n>getline</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>),</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer_length</span><span class=p>),</span> <span class=n>stdin</span><span class=p>);</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>bytes_read</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error reading input</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Ignore trailing newline
</span><span class=c1></span>  <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>input_length</span> <span class=o>=</span> <span class=n>bytes_read</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>[</span><span class=n>bytes_read</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span></code></pre></div><p>Now it is proper to define a function that frees the memory allocated for an
instance of <code>InputBuffer *</code> and the <code>buffer</code> element of the respective
structure (<code>getline</code> allocates memory for <code>input_buffer-&gt;buffer</code> in
<code>read_input</code>).</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>close_input_buffer</span><span class=p>(</span><span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>free</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>);</span>
    <span class=n>free</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>
<span class=p>}</span></code></pre></div><p>Finally, we parse and execute the command. There is only one recognized command right now : <code>.exit</code>, which terminates the program. Otherwise we print an error message and continue the loop.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>,</span> <span class=s>&#34;.exit&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>close_input_buffer</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>
  <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Unrecognized command &#39;%s&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>input_buffer</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>);</span>
<span class=p>}</span></code></pre></div><p>Let&rsquo;s try it out!</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>~ ./db
db &gt; .tables
Unrecognized <span class=nb>command</span> <span class=s1>&#39;.tables&#39;</span>.
db &gt; .exit
~</code></pre></div><p>Alright, we&rsquo;ve got a working REPL. In the next part, we&rsquo;ll start developing our command language. Meanwhile, here&rsquo;s the entire program from this part:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&amp;lt;stdbool.h&amp;gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&amp;lt;stdio.h&amp;gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&amp;lt;stdlib.h&amp;gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&amp;lt;string.h&amp;gt;</span><span class=cp>
</span><span class=cp></span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
  <span class=kt>char</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>
  <span class=n>size_t</span> <span class=n>buffer_length</span><span class=p>;</span>
  <span class=n>ssize_t</span> <span class=n>input_length</span><span class=p>;</span>
<span class=p>}</span> <span class=n>InputBuffer</span><span class=p>;</span>

<span class=n>InputBuffer</span><span class=o>*</span> <span class=nf>new_input_buffer</span><span class=p>()</span> <span class=p>{</span>
  <span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>InputBuffer</span><span class=p>));</span>
  <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer_length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>input_length</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=k>return</span> <span class=n>input_buffer</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>print_prompt</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;</span><span class=n>db</span> <span class=o>&amp;</span><span class=n>gt</span><span class=p>;</span> <span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;);</span> <span class=p>}</span>

<span class=kt>void</span> <span class=nf>read_input</span><span class=p>(</span><span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>ssize_t</span> <span class=n>bytes_read</span> <span class=o>=</span>
      <span class=n>getline</span><span class=p>(</span><span class=o>&amp;</span><span class=n>amp</span><span class=p>;(</span><span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>amp</span><span class=p>;(</span><span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer_length</span><span class=p>),</span> <span class=n>stdin</span><span class=p>);</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>bytes_read</span> <span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;</span><span class=n>Error</span> <span class=n>reading</span> <span class=n>input</span><span class=err>\</span><span class=n>n</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;);</span>
    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=c1>// Ignore trailing newline
</span><span class=c1></span>  <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>input_length</span> <span class=o>=</span> <span class=n>bytes_read</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
  <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span><span class=p>[</span><span class=n>bytes_read</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>close_input_buffer</span><span class=p>(</span><span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>free</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span><span class=p>);</span>
    <span class=n>free</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
  <span class=n>InputBuffer</span><span class=o>*</span> <span class=n>input_buffer</span> <span class=o>=</span> <span class=n>new_input_buffer</span><span class=p>();</span>
  <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>print_prompt</span><span class=p>();</span>
    <span class=n>read_input</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;.</span><span class=n>exit</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>close_input_buffer</span><span class=p>(</span><span class=n>input_buffer</span><span class=p>);</span>
      <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;</span><span class=n>Unrecognized</span> <span class=n>command</span> <span class=o>&amp;</span><span class=err>#</span><span class=mi>39</span><span class=p>;</span><span class=o>%</span><span class=n>s</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>39</span><span class=p>;.</span><span class=err>\</span><span class=n>n</span><span class=o>&amp;</span><span class=err>#</span><span class=mi>34</span><span class=p>;,</span> <span class=n>input_buffer</span><span class=o>-&amp;</span><span class=n>gt</span><span class=p>;</span><span class=n>buffer</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></div><div class=edit-meta><br><a href=https://github.com/stanzheng/build-a-db/edit/master/content/using_c/part1.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/using_c/ title="How Does a Database Work? In [C]"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - How Does a Database Work? In [C]</a>
<a class="nav nav-next" href=/using_c/part2/ title="Part 2 - World's Simplest SQL Compiler and Virtual Machine">Next - Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=http://build-a-db.stanzheng.com/>Home</a></li><li class=parent><a href=/using_c/>How Does a Database Work? In [C]</a><ul class=sub-menu><li class=active><a href=/using_c/part1/>Part 1 - Introduction and Setting up the REPL</a></li><li><a href=/using_c/part2/>Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine</a></li><li><a href=/using_c/part3/>Part 3 - An In-Memory, Append-Only, Single-Table Database</a></li><li><a href=/using_c/part4/>Part 4 - Our First Tests (and Bugs)</a></li><li><a href=/using_c/part5/>Part 5 - Persistence to Disk</a></li><li><a href=/using_c/part6/>Part 6 - The Cursor Abstraction</a></li><li><a href=/using_c/part7/>Part 7 - Introduction to the B-Tree</a></li><li><a href=/using_c/part8/>Part 8 - B-Tree Leaf Node Format</a></li><li><a href=/using_c/part9/>Part 9 - Binary Search and Duplicate Keys</a></li><li><a href=/using_c/part10/>Part 10 - Splitting a Leaf Node</a></li><li><a href=/using_c/part11/>Part 11 - Recursively Searching the B-Tree</a></li><li><a href=/using_c/part12/>Part 12 - Scanning a Multi-Level B-Tree</a></li><li><a href=/using_c/part13/>Part 13 - Updating Parent Node After a Split</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>