<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Build a database in X</title><link>https://build-a-db.stanzheng.com/</link><description>Recent content on Build a database in X</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://build-a-db.stanzheng.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Part 1 - Introduction and Setting up the REPL</title><link>https://build-a-db.stanzheng.com/using_c/part1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part1/</guid><description>As a web developer, I use relational databases every day at my job, but they&amp;rsquo;re a black box to me.
Some questions I have:
What format is data saved in? (in memory and on disk) When does it move from memory to disk? Why can there only be one primary key per table? How does rolling back a transaction work? How are indexes formatted? When and how does a full table scan happen?</description></item><item><title>Part 2 - World&#39;s Simplest SQL Compiler and Virtual Machine</title><link>https://build-a-db.stanzheng.com/using_c/part2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part2/</guid><description>We&amp;rsquo;re making a clone of sqlite. The &amp;ldquo;front-end&amp;rdquo; of sqlite is a SQL compiler that parses a string and outputs an internal representation called bytecode.
This bytecode is passed to the virtual machine, which executes it.
{% include image.html url=&amp;ldquo;assets/images/arch2.gif&amp;rdquo; description=&amp;ldquo;SQLite Architecture (https://www.sqlite.org/arch.html)&amp;quot; %}
Breaking things into two steps like this has a couple advantages: - Reduces the complexity of each part (e.g. virtual machine does not worry about syntax errors) - Allows compiling common queries once and caching the bytecode for improved performance</description></item><item><title>Part 3 - An In-Memory, Append-Only, Single-Table Database</title><link>https://build-a-db.stanzheng.com/using_c/part3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part3/</guid><description>We&amp;rsquo;re going to start small by putting a lot of limitations on our database. For now, it will:
support two operations: inserting a row and printing all rows reside only in memory (no persistence to disk) support a single, hard-coded table Our hard-coded table is going to store users and look like this:
column type id integer username varchar(32) email varchar(255) This is a simple schema, but it gets us to support multiple data types and multiple sizes of text data types.</description></item><item><title>Part 4 - Our First Tests (and Bugs)</title><link>https://build-a-db.stanzheng.com/using_c/part4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part4/</guid><description>We&amp;rsquo;ve got the ability to insert rows into our database and to print out all rows. Let&amp;rsquo;s take a moment to test what we&amp;rsquo;ve got so far.
I&amp;rsquo;m going to use rspec to write my tests because I&amp;rsquo;m familiar with it, and the syntax is fairly readable.
I&amp;rsquo;ll define a short helper to send a list of commands to our database program then make assertions about the output:
describe &amp;#39;database&amp;#39; do def run_script(commands) raw_output = nil IO.</description></item><item><title>Part 5 - Persistence to Disk</title><link>https://build-a-db.stanzheng.com/using_c/part5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part5/</guid><description>&amp;ldquo;Nothing in the world can take the place of persistence.&amp;rdquo; &amp;ndash; Calvin Coolidge
Our database lets you insert records and read them back out, but only as long as you keep the program running. If you kill the program and start it back up, all your records are gone. Here&amp;rsquo;s a spec for the behavior we want:
it &amp;#39;keeps data after closing connection&amp;#39; do result1 = run_script([ &amp;#34;insert 1 user1 person1@example.</description></item><item><title>Part 6 - The Cursor Abstraction</title><link>https://build-a-db.stanzheng.com/using_c/part6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part6/</guid><description>This should be a shorter part than the last one. We&amp;rsquo;re just going to refactor a bit to make it easier to start the B-Tree implementation.
We&amp;rsquo;re going to add a Cursor object which represents a location in the table. Things you might want to do with cursors:
Create a cursor at the beginning of the table Create a cursor at the end of the table Access the row the cursor is pointing to Advance the cursor to the next row Those are the behaviors we&amp;rsquo;re going to implement now.</description></item><item><title>Part 7 - Introduction to the B-Tree</title><link>https://build-a-db.stanzheng.com/using_c/part7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part7/</guid><description>The B-Tree is the data structure SQLite uses to represent both tables and indexes, so it&amp;rsquo;s a pretty central idea. This article will just introduce the data structure, so it won&amp;rsquo;t have any code.
Why is a tree a good data structure for a database?
Searching for a particular value is fast (logarithmic time) Inserting / deleting a value you&amp;rsquo;ve already found is fast (constant-ish time to rebalance) Traversing a range of values is fast (unlike a hash map) A B-Tree is different from a binary tree (the &amp;ldquo;B&amp;rdquo; probably stands for the inventor&amp;rsquo;s name, but could also stand for &amp;ldquo;balanced&amp;rdquo;).</description></item><item><title>Part 8 - B-Tree Leaf Node Format</title><link>https://build-a-db.stanzheng.com/using_c/part8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part8/</guid><description>We&amp;rsquo;re changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we&amp;rsquo;ll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let&amp;rsquo;s recap the reasons for switching to a tree structure.
Alternative Table Formats With the current format, each page stores only rows (no metadata) so it is pretty space efficient.</description></item><item><title>Part 9 - Binary Search and Duplicate Keys</title><link>https://build-a-db.stanzheng.com/using_c/part9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part9/</guid><description>Last time we noted that we&amp;rsquo;re still storing keys in unsorted order. We&amp;rsquo;re going to fix that problem, plus detect and reject duplicate keys.
Right now, our execute_insert() function always chooses to insert at the end of the table. Instead, we should search the table for the correct place to insert, then insert there. If the key already exists there, return an error.
ExecuteResult execute_insert(Statement* statement, Table* table) { void* node = get_page(table-&amp;gt;pager, table-&amp;gt;root_page_num); - if ((*leaf_node_num_cells(node) &amp;gt;= LEAF_NODE_MAX_CELLS)) { + uint32_t num_cells = (*leaf_node_num_cells(node)); + if (num_cells &amp;gt;= LEAF_NODE_MAX_CELLS) { return EXECUTE_TABLE_FULL; } Row* row_to_insert = &amp;amp;(statement-&amp;gt;row_to_insert); - Cursor* cursor = table_end(table); + uint32_t key_to_insert = row_to_insert-&amp;gt;id; + Cursor* cursor = table_find(table, key_to_insert); + + if (cursor-&amp;gt;cell_num &amp;lt; num_cells) { + uint32_t key_at_index = *leaf_node_key(node, cursor-&amp;gt;cell_num); + if (key_at_index == key_to_insert) { + return EXECUTE_DUPLICATE_KEY; + } + } leaf_node_insert(cursor, row_to_insert-&amp;gt;id, row_to_insert); We don&amp;rsquo;t need the table_end() function anymore.</description></item><item><title>Part 10 - Splitting a Leaf Node</title><link>https://build-a-db.stanzheng.com/using_c/part10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part10/</guid><description>Our B-Tree doesn&amp;rsquo;t feel like much of a tree with only one node. To fix that, we need some code to split a leaf node in twain. And after that, we need to create an internal node to serve as a parent for the two leaf nodes.
Basically our goal for this article is to go from this:
{% include image.html url=&amp;ldquo;assets/images/btree2.png&amp;rdquo; description=&amp;ldquo;one-node btree&amp;rdquo; %}
to this:
{% include image.</description></item><item><title>Hello world!</title><link>https://build-a-db.stanzheng.com/hello_world/</link><pubDate>Tue, 17 Oct 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/hello_world/</guid><description>Hello world!</description></item><item><title>Hello_world</title><link>https://build-a-db.stanzheng.com/posts/hello_world/</link><pubDate>Tue, 17 Oct 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/posts/hello_world/</guid><description>aaaaaa
vvvv
aaa</description></item><item><title>Part 11 - Recursively Searching the B-Tree</title><link>https://build-a-db.stanzheng.com/using_c/part11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part11/</guid><description>Last time we ended with an error inserting our 15th row:
db &amp;gt; insert 15 user15 person15@example.com Need to implement searching an internal node First, replace the code stub with a new function call.
if (get_node_type(root_node) == NODE_LEAF) { return leaf_node_find(table, root_page_num, key); } else { - printf(&amp;#34;Need to implement searching an internal node\n&amp;#34;); - exit(EXIT_FAILURE); + return internal_node_find(table, root_page_num, key); } } This function will perform binary search to find the child that should contain the given key.</description></item><item><title>Part 12 - Scanning a Multi-Level B-Tree</title><link>https://build-a-db.stanzheng.com/using_c/part12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part12/</guid><description>We now support constructing a multi-level btree, but we&amp;rsquo;ve broken select statements in the process. Here&amp;rsquo;s a test case that inserts 15 rows and then tries to print them.
+ it &amp;#39;prints all rows in a multi-level tree&amp;#39; do + script = [] + (1..15).each do |i| + script &amp;lt;&amp;lt; &amp;#34;insert #{i} user#{i} person#{i}@example.com&amp;#34; + end + script &amp;lt;&amp;lt; &amp;#34;select&amp;#34; + script &amp;lt;&amp;lt; &amp;#34;.exit&amp;#34; + result = run_script(script) + + expect(result[15.</description></item><item><title>Part 13 - Updating Parent Node After a Split</title><link>https://build-a-db.stanzheng.com/using_c/part13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://build-a-db.stanzheng.com/using_c/part13/</guid><description>For the next step on our epic b-tree implementation journey, we&amp;rsquo;re going to handle fixing up the parent node after splitting a leaf. I&amp;rsquo;m going to use the following example as a reference:
{% include image.html url=&amp;ldquo;assets/images/updating-internal-node.png&amp;rdquo; description=&amp;ldquo;Example of updating internal node&amp;rdquo; %}
In this example, we add the key &amp;ldquo;3&amp;rdquo; to the tree. That causes the left leaf node to split. After the split we fix up the tree by doing the following:</description></item><item><title>Hello_world2</title><link>https://build-a-db.stanzheng.com/entry/hello_world2/</link><pubDate>Sun, 17 Dec 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/entry/hello_world2/</guid><description>aaaaaa
vvvv
aaa</description></item><item><title>Hello_world1</title><link>https://build-a-db.stanzheng.com/blog/hello_world1/</link><pubDate>Fri, 17 Nov 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/blog/hello_world1/</guid><description>aaaaaa
vvvv
aaa</description></item><item><title>Hello_world1</title><link>https://build-a-db.stanzheng.com/entry/hello_world1/</link><pubDate>Fri, 17 Nov 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/entry/hello_world1/</guid><description>aaaaaa
vvvv
aaa</description></item><item><title>Hello_world</title><link>https://build-a-db.stanzheng.com/blog/hello_world/</link><pubDate>Tue, 17 Oct 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/blog/hello_world/</guid><description>aaaaaa
vvvv
aaa</description></item><item><title>Hello_world</title><link>https://build-a-db.stanzheng.com/entry/hello_world/</link><pubDate>Tue, 17 Oct 2017 14:00:45 +0000</pubDate><guid>https://build-a-db.stanzheng.com/entry/hello_world/</guid><description>aaaaaa
vvvv
aaa</description></item></channel></rss>